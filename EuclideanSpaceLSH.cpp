#include "EuclideanSpaceLSH.h"


long long int uniform_int_distrib_Lsh(){
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> dis(-100, 100);

    return dis(gen);
}

//=========================================================
//=========================================================


F_HF_Obj::F_HF_Obj(  unsigned  int k ) :  k(k)   {
//    cout << " F_HF_Obj Constructor was called " <<endl;
    assign_r_values();

}

//=========================================================

void F_HF_Obj::assign_r_values() { //TODO na pairnie san orisma to k kai na mhn uparxei constructor
    unsigned  int i ;
    long long int j;
    for (i = 0; i < this->k ; ++i) {
        j = uniform_int_distrib_Lsh();
        r_values.push_back(j);
    }

}

//=========================================================

const vector<long long int> &F_HF_Obj::getR_values() const {
    return r_values;
}
//=========================================================

void F_HF_Obj::print_F_r_values() const {
    cout << "r values are : ";
    for (auto &r : this->r_values) {
        cout << "\t" << r ;
    }
    cout << endl;
}


//=========================================================
//=========================================================

H_Class_Lsh::H_Class_Lsh(unsigned int& W,unsigned int& d)  : W(W) , d(d) {
//    cout << " H_Class_Lsh Constructor was called " <<endl;
}

//=========================================================

void H_Class_Lsh::assign_v_t(){
    uniform_distrib(); //uniform_real_distribution()
    normal_distrib(this->d);
}

//=========================================================

long long int  H_Class_Lsh::calculate_h_fun(myVector& p) const{
    double h_value;
    long long int val;
    double dot,numerator;
    dot = p.dot_product(this->v);
    numerator = dot + (double)this->t;
    h_value = numerator / ((double) this->W );
    val = static_cast<long long int>(floor(h_value));
    return val;
}

//=========================================================

//float uniform_distrib();
void H_Class_Lsh::uniform_distrib(){
    std::random_device rd; //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0, W);
    //Use dis to transform the random unsigned int generated by gen into a double in [1, 2)
    this->t = float(dis(gen));

}

//=========================================================

void H_Class_Lsh::normal_distrib(unsigned int& dim){
    std::random_device rd{};
    std::mt19937 gen{rd()};

    // values near the mean are the most likely
    // standard deviation affects the dispersion of generated values from the mean
    std::normal_distribution<> d{0,1};
    double v_coord;
    unsigned int n;
    std::vector<double> v_temp;

    for(n=0; n<dim; ++n) {
        v_coord = d(gen);

        v_temp.push_back(v_coord);
    }
    this-> v.setCoords(v_temp);

}

//=========================================================

void H_Class_Lsh::print_h() const{
    std::cout << "t = " << t << " \t W = " << W << " \t & v = "<< endl;
    v.print_vector();
}

//=========================================================
//=========================================================

EuclideanSpaceLSH::EuclideanSpaceLSH(unsigned  int TableSize,
                                     unsigned int k, unsigned int W,unsigned int d , long long int  M) : TableSize(TableSize),   k(k) ,W(W) , d(d) ,M(M) {

    cout << "EuclideanSpaceLSH Constructor called " << endl;

    std::vector<H_Class_Lsh> h_classes(k, H_Class_Lsh(W,d));
    for (auto &h : h_classes) {
        h.assign_v_t();
    }

    this->h_chain = h_classes;

    F_HF_Obj F( k );

    this->F_HF =  F ;

}

//=========================================================

unsigned  int EuclideanSpaceLSH::get_HT_index(myVector& p ) const{
    long long int temp_val_h_p;
    long long int x;

    unsigned int retur_f;
    std::vector<long long int> h_p_chain;
    for (auto &h : this->h_chain) {
        temp_val_h_p = h.calculate_h_fun(p);
        h_p_chain.push_back(temp_val_h_p);
    }
    //here I have all the h_p
    //now I have to find the r_i ---> Ï†

    vector<long long int >::const_iterator  ItA,ItB;
    assert(this->getF_HF().getR_values().size() == h_p_chain.size( ));



    ItA = this->getF_HF().getR_values().begin();
    ItB = h_p_chain.begin();
    long long int f_value =0;

    while(true)
    {

        x = ( ( (*ItA) % this->M ) * ( (*ItB) % this->M ) ) % this->M ;          //// (A * B) mod C = (A mod C * B mod C) mod C
        f_value +=  (x  + this->M) % this->M;  ////    x mod n = (x % n + n) % n

//        assert(f_value < this->M);


        if(ItA != this->getF_HF().getR_values().end())
        {
            ++ItA;
        }
        if(ItB != h_p_chain.end())
        {
            ++ItB;
        }
        if(ItA == this->getF_HF().getR_values().end() && ItB == h_p_chain.end())
        {
            f_value = f_value % this->M;
            assert(f_value < this->M);

            break;
        }
    }


    retur_f = static_cast<unsigned int>(f_value % (TableSize));
    assert(retur_f < this->TableSize);

    return retur_f;

}

//=========================================================

string EuclideanSpaceLSH::g(myVector& p){
    string all_string;  //(this->k);
    string curr_str;
    for (auto &h: this->h_chain) {

        curr_str = std::to_string(h.calculate_h_fun(p));
        all_string += curr_str + ",";

    }

    return all_string;
}

//=========================================================

const vector<H_Class_Lsh> &EuclideanSpaceLSH::getH_chain() const {
    return h_chain;
}
//=========================================================

const F_HF_Obj &EuclideanSpaceLSH::getF_HF() const {
    return F_HF;
}
//=========================================================

void EuclideanSpaceLSH::print_EuclideanSpaceLSH() const {
//    cout << "~~~~EuclideanSpaceLSH has ~~~~ " << endl;
    for (auto &h : h_chain) {
        h.print_h();
    }
    cout << "================="<<endl;
    cout << "with r values in f "<<endl;
    F_HF.print_F_r_values();

    cout << "~~~~EuclideanSpaceLSH ends here ~~~~ " << endl;
}



